<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>JsonMarshaller</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link href="code.css" rel="stylesheet" type="text/css"></link>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
    <script type="text/javascript">
    _uacct = "UA-2439014-2";
    urchinTracker();
    </script>
    <link href="prettify.css" type="text/css" rel="stylesheet" />
    <script type="text/javascript" src="prettify.js"></script>
  </head>
<body class="light" onload="prettyPrint()">
  <div class="wrapper">
    <div class="page">
      <div class="lighttop fy">&nbsp;<img src="logo.png" alt="Two Lattes. lists for everyone" /></div>
      <div class="spacer" style="height:15px">&nbsp;</div>
    <div>
<!-- sidebar -->
<div class="sidebar">
<span class="section greetingblue">News</span>
<p>Version 0.9 is out with great new features
<ul>
<li>Annotate entities with
<tt>inline</tt> to have them always inlined, even if they are in a
<tt>Collection</tt> or a <tt>Map</tt></li>
<li>Use <tt>@Value</tt> on getters and setters! Now you can annotate interfaces
as well.</li>
</ul></p>
<p>Version 0.8 is the <b>fastest JSON marshalling</b> library on the web!
<a href="http://sourceforge.net/project/showfiles.php?group_id=192108">Download</a> now, or
check the <a href="2007_11_19_15_02/index.html" target="_blank">report (11/19/2007)</a>.</p>
<p>Version 0.6 is out, we added <a href="#viewsOption">views</a>.</p>

<span class="section greetingblue">Quick Access</span>

<ul>
  <li><a href="#entities">Entities</a></li>
  <li><a href="#annotations">Annotations</a>
    <ul>
      <li><a href="#nameOption"><tt>name</tt> option</a></li>
      <li><a href="#optionalOption"><tt>optional</tt> option</a></li>
      <li><a href="#inlineOption"><tt>inline</tt> option</a></li>
      <li><a href="#typeOption"><tt>type</tt> option</a></li>
      <li><a href="#viewsOption"><tt>views</tt> option</a></li>
    </ul>
  </li>
  <li><a href="#udt">User Defined Types</a></li>
  <li><a href="#mu">Marshalling and Unmarshalling</a></li>
  <li><a href="#exa_delicious">del.icio.us feeds</a></li>
</ul>

<span class="section greetingblue">Download</span>
<p><a href="http://sourceforge.net/project/showfiles.php?group_id=192108">sourceforge.net</a><br />
<br />
The project's files are available on sourceforge.net.</p>

<span class="section greetingblue">Credits &amp; License</span>
<p>This project uses</p>
<ul>
  <li><a href="http://www.json.org/java/index.html" target="_blank">org.json parser</a></li>
  <li><a href="http://asm.objectweb.org" target="_blank">ASM</a></li>
  <li><a href="http://www.junit.org" target="_blank">JUnit</a></li>
</ul>
<p>and is licensed under the<br/>
<br/>
<a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache License, Version 2.0</a>.</p>
<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0 Transitional" height="31" width="88" border="0" /></a></p>
<script type="text/javascript" language="JavaScript" src="http://www.ohloh.net/projects/8014/badge_js"></script>
</div>

<!-- content -->
<div class="content">
<span class="section greetingblue" id="top">JsonMarshaller</span>
<p>JSON is an ever more popular data representation. In the web 2.0 revolution,
it is the de facto choice for many applications, including TwoLattes&#39;.</p>

<p><b>JsonMarshaller</b> is a Java 1.5 library that allows marshalling and unmarshalling
of JSON objects to and from entities (&quot;Java classes&quot;). This project's goal
is above all ease of use, transparency and static type safety. It is also the
<b>fastest library</b>, check out the
<a href="2007_11_19_15_02/index.html" target="_blank">report (11/19/2007)</a>.</p>

<p>To learn more about JSON, read about its syntax, its advantages or disadvantages,
please refer to the <a href="http://lists.twolattes.com/json" target="_blank">JSON Ressources list</a>
as we will skim over a formal presentation.</p>

<p>Let start with some examples. Suppose your are building a bookstore and want to
represent books and authors. You might have two Java classes similar to
(we will discuss the annotations in a minute):</p>
<pre class="code prettyprint">@Entity
class Book {
  @Value
  private String title;
  @Value
  private String isbn;
  @Value
  private Set&lt;Author&gt; authors;
}

@Entity
class Author {
  @Value
  private String firstName;
  @Value
  private String lastName;
}</pre>
<p>and from an instance of a book, build the JSON object</p>
<pre class="code prettyprint">{&quot;title&quot;:   "Vocation Createurs",
 &quot;isbn&quot;:    "2829302680",
 &quot;authors&quot;: [{&quot;firstName&quot;: "Barbara", &quot;lastName&quot;: "Polla"},
             {&quot;firstName&quot;: "Pascal",  &quot;lastName&quot;: "Perez"}]}</pre>
<p>or vice-versa: you have a JSON representation and wish to create Java instances
automatically from it. <b>JsonMarshaller</b> offers exactly that.</p>
<pre class="code prettyprint">...
Book vocationCreateurs = ...;
Marshaller&lt;Book&gt; m = Marshaller.create(Book.class);
JSONObject o = m.marshall(vocationCreateurs);
...</pre>
<p>and</p>
<pre class="code prettyprint">...
JSONObject o = ...;
Marshaller&lt;Book&gt; m = Marshaller.create(Book.class);
Book vocationCreateurs = m.unmarshall(o);
...</pre>
<p>Everything needed is automatically inferred from the bytecode of the
<tt>Book</tt> class!</p>

<p><span class="subsection greetingblue" id="entities">Entities (<a href="#top" class="top">top&uarr;</a>)</span></p>

<p>Entities represent the domain model. They are objects holding data, such as <tt>Book</tt>, <tt>Auhtor</tt>,
<tt>User</tt>, or <tt>Account</tt>. On the other hand, an <tt>InpusStream</tt> object for instance, represents
computation.<br />
<br />
To work with the <b>JsonMarshaller</b>, your entities should provide a no argument constructor. This allows
the marshaller to create fresh instances and populate them.</p>

<p><span class="subsection greetingblue" id="annotations">Annotations (<a href="#top" class="top">top&uarr;</a>)</span></p>

<p>The <b>JsonMarshaller</b> uses two annotations to describe entities: <tt>@Entity</tt> and
<tt>@Value</tt>.<br />
<br />
As we have seen</p>
<pre class="code prettyprint">@Entity
class Book {
  ...</pre>
<p>the <tt>@Entity</tt> annotates a class and informs the marshaller that it is a
JSON entity. Again, entities <u>should have a no argument constructor</u>.<br />
<br />
The second annotation</p>
<pre class="code prettyprint">  @Value
  String firstName;</pre>
<p>informs the marshaller that the field should be persisted to JSON. Non annotated
fields are considered transient (will not be persisted).</p>

<p><span class="subsubsection greetingblue" id="nameOption"><tt>name</tt> option (<a href="#top" class="top">top&uarr;</a>)</span></p>

<p>When an entitiy is marshalled, the Java field name is used. To override this default
behaviour, you can use the <tt>name</tt> option</p>
<pre class="code prettyprint">  @Value(name = &quot;fname&quot;)
  String firstName;</pre>
<p>This would be marshalled to</p>
<pre class="code prettyprint">{..., &quot;fname&quot;: &quot;Pascal&quot;, ...}</pre>
<p>instead of</p>
<pre class="code prettyprint">{..., &quot;firstName&quot;: &quot;Pascal&quot;, ...}</pre>

<p><span class="subsubsection greetingblue" id="optionalOption"><tt>optional</tt> option (<a href="#top" class="top">top&uarr;</a>)</span></p>

<p>The <tt>optional</tt> option indicates that a value is optional. When unmarshalling
an entity, if the value is not found no exception will be thrown. This allows
to define defaults to certain properties of an entity that are overridden only
if a value is specified. For instance</p>
<pre class="code prettyprint">@Entity
class Email {
  @Value(optional = true)
  private String email = &quot;support@mydomain.com&quot;;
}</pre>

<p><span class="subsubsection greetingblue" id="inlineOption"><tt>inline</tt> option (<a href="#top" class="top">top&uarr;</a>)</span></p>

<p>The <tt>inline</tt> options allows you to inline an entity into another. Suppose you have
a <tt>User</tt> entity with an <tt>email</tt> field represented by an <tt>Email</tt> entity</p>
<pre class="code prettyprint">@Entity
class User {
  @Value(inline = true)
  private Email email;
}

@Entity
class Email {
  @Value
  private String email;
}</pre>
<p>Specifying <tt>inline = true</tt> informs the marshaller that inlining should occur. The JSON
object produced would then be</p>
<pre class="code prettyprint">{..., &quot;email&quot;: &quot;hello@world.com&quot;, ...}</pre>
<p>Without inlining, we would have</p>
<pre class="code prettyprint">{..., &quot;email&quot;: {&quot;email&quot;: &quot;hello@world.com&quot;}, ...}</pre>
<p>Not that an entity can be inlined only if it has only one value field.</p>
<p>You might also want to specify that an entity should always be inlined. For
this put the <tt>inline = true</tt> option on the <tt>@Entity</tt>
annotation</p>
<pre class="code prettyprint">@Entity(inline = true)
class Email {
  @Value
  private String email;
}</pre>
<p>In addition to locality, specifying the inlining at the entity level ensures
it will be inlined even if it is in a <tt>List</tt>, <tt>Map</tt> or
<tt>Set</tt>. For instance, the following class
<pre class="code prettyprint">@Entity
class User {
  @Value
  private Set&lt;Email&gt; email;
}

@Entity(inline = true)
class Email {
  @Value
  private String email;
}</pre>
<p>would be marshalled to</p>
<pre class="code prettyprint">{&quot;email&quot;: [&quot;foo@bar.edu&quot;, &quot;hello@world.com&quot;, ...]}</pre>

<p><span class="subsubsection greetingblue" id="typeOption"><tt>type</tt> option (<a href="#top" class="top">top&uarr;</a>)</span></p>

<p>The <tt>type</tt> option allows you to specify a user defined type for a value.
Suppose your entity contains a field which is not a JSON entity</p>
<pre class="code prettyprint">
@Entity
class Address {
  @Value
  private String name;
  @Value(type = com.twolattes.json.types.URLType.class)
  private URL url;
}</pre>
<p>here the <tt>URL</tt> is a value yet we cannot marshall and unmarshall it
without additional information wich the <tt>URLType</tt> provides. In the next section
we discuss the creation of a user defined type.</p>

<p><span class="subsubsection greetingblue" id="viewsOption"><tt>views</tt> option (<a href="#top" class="top">top&uarr;</a>)</span></p>

<p>Do you happen to have complex entities which need to be marshalled once with
a set of fields, and in another situation with other fields? Views allow you
to specify different waays to marshall entities. The <tt>views</tt> option
takes a <tt>String</tt> array as parameter which are the views in which a
field ought to be included. Consider the <tt>Address</tt> class.</p>
<pre class="code prettyprint">
@Entity
class Address {
  @Value(views = {&quot;full&quot;, &quot;simple&quot;}
  private String name;
  @Value(views = {&quot;full&quot;},
         type = com.twolattes.json.types.URLType.class)
  private URL url;
}</pre>
<p>The <tt>name</tt> field will be marshalled in the <tt>full</tt> and
<tt>simple</tt> views, whereas the <tt>url</tt> field will only be marshalled in
the <tt>full</tt> view.</p>
<p>To specify the view of an entity to take when marshalling or unmarshalling,
please look out the updated <a href="#mu">interface</a> of the
<tt>Marshaller</tt>.</p>

<p><span class="subsection greetingblue" id="udt">User Defined Types (<a href="#top" class="top">top&uarr;</a>)</span></p>

<p>A user defined type must implement the interface <tt>com.twolattes.json.types.Type</tt></p>
<pre class="code prettyprint">
public interface Type&lt;T&gt; {
  public Class&lt;T&gt; getReturnedClass();
  public Object marshall(T entity);
  public T unmarshall(Object object);
}</pre>
<p>The <tt>getReturnedClass</tt> return the <tt>Class</tt> object which represents the
type <tt>T</tt>. The <tt>marshall</tt> and <tt>unmarshall</tt> methods take care
of marshalling and unmarshalling.<br />
<br />
To write your own, look at the <tt>URLType</tt> as an example.</p>

<p><span class="subsubsection greetingblue" id="registertypes">Registering types</span></p>

<p>The <tt>type</tt> option of the <tt>@Value</tt> is nice and useful, but what
if you reuse over and over the same type? In version 0.5 we've added a way to
register frequently used types.</p>
<pre class="code prettyprint">Marshaller.register(new URLType());</pre>
<p>Now every occurrence of <tt>URL</tt> in an entity will automatically use
this registered type, just as if you had it specified on a per-field basis.</p>

<p><span class="subsection greetingblue" id="mu">Marshalling and Unmarshalling (<a href="#top" class="top">top&uarr;</a>)</span></p>

<p>A marshaller is created with the static function</p>
<pre class="code prettyprint">Marshaller.create(Book.class)</pre>
<p>you will note that the marshaller's constructor is private. This allows our implementation
to do thread local interning and therefore cut the cost of initialization (reading
the byte code and inferring the entity's structure) across multiple usages.</p>
<p class="important">We have changed the interface to the marshaller in
release <b>0.9</b>: the marshalling methods do not throw a <tt>JSONException</tt>
anymore. This means that if you had an exception handler around the marshalling
call, the compiler will produce an error about this code never throwing this
exception. Whilst this backward compatibility issue may annoy some of you,
we believe it will pay off in the long run.</p>
<p>The marshaller offers eight marshalling methods. The simplest marshalls an
entity.</p>
<pre class="code prettyprint">JSONObject marshall(T entity)</pre>
<p>The next, marshalls an entitiy within a specific view (see the
<a href="#viewsOption">views</a> option for more detail).</p>
<pre class="code prettyprint">JSONObject marshall(T entity, String view)</pre>
<!--<pre class="code prettyprint">JSONObject marshall(T entity, boolean cyclic)</pre>
<pre class="code prettyprint">JSONObject marshall(T entity, boolean cyclic, String view)</pre>-->
<p>Convenience methods are offered to marshall collections of entities at once.</p>
<pre class="code prettyprint">JSONArray marshallList(Collection&lt;? extends T&gt; entities)
JSONArray marshallList(Collection&lt;? extends T&gt; entities, String view)</pre>
<!--<pre class="code prettyprint">JSONArray marshallList(Collection&gt;? extends T&lt; entities, boolean cyclic)</pre>
<pre class="code prettyprint">JSONArray marshallList(Collection&gt;? extends T&lt; entities, boolean cyclic, String view)</pre>-->
<p>Unmarshalling methods are dually defined.</p>
<pre class="code prettyprint">T unmarshall(JSONObject entity)
T unmarshall(JSONObject entity, String view)
List&lt;T&gt; unmarshallList(JSONArray array)
List&lt;T&gt; unmarshallList(JSONArray array, String view)</pre>
<!--The <tt>boolean cyclic</tt> flag indicates
to the marshaller wether the entity has cyclicity or not.-->

<p><span class="subsection greetingblue" id="exa_delicious">Example : del.icio.us feeds (<a href="#top" class="top">top&uarr;</a>)</span></p>

<p>Here is a typical response from <a href="http://del.icio.us" target="_blank">del.icio.us</a></p>
<pre class="code prettyprint">{"u":"http://code.twolattes.com",
 "d":"TwoLattes's Open Source Code",
 "n":"Home of JsonMarshaller.",
 "t":["JSON","TwoLattes","Java"]}</pre>
<p>which can be represented as</p>
<pre class="code prettyprint">
@Entity
class Bookmark {
  @Value(name = &quot;u&quot;,
         type = com.twolattes.json.types.URLType.class)
  private URL url;
  @Value(name = &quot;d&quot;)
  private String description;
  @Value(name = &quot;n&quot;)
  private String note;
  @Value(name = &quot;t&quot;)
  private Set&lt;String&gt; tags;
}</pre>
<p>It's that easy!</p>
<div class="spacer" style="height: 1px;"></div>
<div class="footer">&copy; 2006,2007 TwoLattes Inc. All rights reserved.</div>
</div>
</div>
</div>
</div>
</body>
</html>
